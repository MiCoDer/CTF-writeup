# dragon slayer

```
Arch:     amd64-64-little
RELRO:    Full RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      PIE enabled
```

## Analysis

這題是一個 RPG，我們有多個角色可以選用，目標是衝高等級之後打敗龍，在那之後還可以做一次程式自帶的任意寫入。不過基於遊戲的限制，在練到要求等級之前早就 timeout 了，另外因為這題開了 `FULL RELRO` 和 `PIE`，我們也需要先 leak 出一些位址資訊。  
在找了好一陣子後終於發現，這支程式的漏洞就出在 `out_of_bound` 這個 function  

```c
int out_of_bound(Character *p){
    // if (characters <= p && p <= characters+N) return 0;
    // 差點寫錯ㄏㄏ
    if (characters <= p && p < characters+N) return 0;
    return 1;
}
```

他只會檢查計算出來的指標是否在整個角色陣列的範圍內，卻沒有檢查這個指標是否確實指向某個 element 的開頭。可以看到算出 `p` 的過程如下，其中 `read_int()` 會讓我們輸入一個 `long long` 的值。

```c
selected = read_int();
if (out_of_bound(&characters[selected])){
    puts("You can not select this!!");
    selected = -1;
    sel = NULL;
    exit(-1);
} else {
    printf("%lld selected\n", selected);
    sel = &characters[selected];
 
```

所以如果輸入一個很大的值，讓計算 `p` 的時候加到 overflow 繞回來的時候歪掉，但結果依舊落在 `characters ` 內部，這樣就能夠透過操作這個不存在的角色來 leak 或 overwrite 其他角色的資訊。

```
                                 |               |
                  characters ->   ---------------
                                 |               |
                                 |               |
characters+0x555555555555556 -> -------------------
                               | |               | |
                characters+1 ->|  ---------------  |
                               | |               | |
                               | |               | |
                                -------------------
                                 |               |
                characters+2 ->   ---------------
                                 |               |
                                 |               |
```

## Exploit

* 首先我利用上述的方式，取得了一個橫跨其他角色結構的角色 (下圖**粗體**虛線處)，就叫他 `chaos` 好了。

<pre>
                   --------------------------------------------
0x55ed0b7d8010:   | 0x0000796464616552      0x0000000000000000 |
0x55ed0b7d8020:   | 0x0000000000000000      0x0000000000000000 |
                 <b>------------------------------------------------</b>
0x55ed0b7d8030: <b>|</b> | 0x000055ed0b7d8170      0x000000010000000a | <b>|</b>
                <b>|</b>  --------------------------------------------  <b>|</b>
0x55ed0b7d8040: <b>|</b> | 0x6567676e617a724f      0x6567676e617a724f | <b>|</b>
0x55ed0b7d8050: <b>|</b> | 0x0000000000000000      0x0000000000000000 | <b>|</b>
                 <b>------------------------------------------------</b>
0x55ed0b7d8060:   | 0x000055ed0b7d8210      0x000000010000000a |
                   --------------------------------------------
0x55ed0b7d8070:   | 0x6f6f6f6f6f6c6159      0x00000000776f6f6f |
0x55ed0b7d8080:   | 0x0000000000000000      0x0000000000000000 |
0x55ed0b7d8090:   | 0x000055ed0b7d82b0      0x000000010000000a |
                   --------------------------------------------
0x55ed0b7d80a0:   | 0x0000006e69697247      0x0000000000000000 |
0x55ed0b7d80b0:   | 0x0000000000000000      0x0000000000000000 |
0x55ed0b7d80c0:   | 0x000055ed0b7d8350      0x000000010000000a |
                   --------------------------------------------
0x55ed0b7d80d0:   | 0x65656565756c7542      0x0000000000006565 |
0x55ed0b7d80e0:   | 0x0000000000000000      0x0000000000000000 |
0x55ed0b7d80f0:   | 0x000055ed0b7d83f0      0x000000010000000a |
                   --------------------------------------------
0x55ed0b7d8100:   | 0x006174656c6f6956      0x0000000000000000 |
0x55ed0b7d8110:   | 0x0000000000000000      0x0000000000000000 |
0x55ed0b7d8120:   | 0x000055ed0b7d8490      0x000000010000000a |
                   --------------------------------------------
0x55ed0b7d8130:   | 0x676e696c70727550      0x0000000000000000 |
0x55ed0b7d8140:   | 0x0000000000000000      0x0000000000000000 |
0x55ed0b7d8150:   | 0x000055ed0b7d8530      0x000000010000000a |
                   --------------------------------------------
</pre>

* 接著我打算對 `chaos` 使用 `craft_weapon`，因為這會在 `0x55ed0b7d8050` 處填上新造武器的指標，接著只要使用 `list()`，在輸出 `"OrzanggeOrzangge"` 時就會 leak 出這個指標，從而取得 heap base。  
* 有了 heap base 之後，我先找個角色把他的武器玩壞並被 `free` 掉，讓 `unsorted bin` 的位址被填上該武器的 `durability` 欄位。接著我利用 `change_name` 來把 `Readdy` 的 `weapons` 蓋成指向這個武器 chunk 的 `fd` 欄位，這樣接下來 `list()` 的時候就可以取得 libc 位址資訊。
* 有了 libc base 後就進入了最後階段，我再次用 `change_name` 把 `Readdy` 的 `energy` 和 `level` 蓋成很大的值，至於 `weapons` 則蓋成 `vsyscall` 中的位址來避免 `strcpy` 截斷內容。  

	> vsyscall 的部分我在 local 測會壞掉，丟 remote 卻能順利運作，不清楚是甚麼原因

	如此一來打敗龍的條件就滿足了，勝利之後我選擇在 `__malloc_hook` 寫入 one gadget，然後去造把武器觸發 `malloc` 就能夠開 shell 了。

flag: `FLAG{1t_4ctually_IS_wi7hin_b0und...}`
